<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coderative-A NFT Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: "Courier New", Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        .container {
            text-align: left;
            width: 50%;
            background: #001f00;
            border: 2px solid #0f0;
            padding: 20px;
            box-shadow: 0 0 10px #0f0;
        }

        h1 {
            font-family: "Courier New", Courier, monospace;
            text-align: center;
            color: #0f0;
            font-size: 2rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
        }

        button, select {
            display: block;
            margin-bottom: 10px;
            width: 100%;
            padding: 10px;
            font-size: 1rem;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            cursor: pointer;
        }

        button:hover, select:hover {
            background: #0f0;
            color: #000;
        }

        canvas {
            margin: 20px auto;
            display: block;
            border: 2px solid #0f0;
            max-width: 100%;
            max-height: 70vh;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Coderative-A NFT Viewer</h1>
        <p>Connect your wallet to generate your NFT art.</p>
        <button id="connectWallet">Connect Wallet</button>
        <p id="walletAddress">Address: Not connected</p>

        <form id="nftForm" style="display: none;">
            <label for="size">Size:</label>
            <select id="size">
                <option value="512x512">PFP Social Media (512x512)</option>
                <option value="1920x1080">Wallpaper (1920x1080)</option>
                <option value="1080x1920">Mobile Wallpaper (1080x1920)</option>
                <option value="1500x500">Social Media Banner (1500x500)</option>
            </select><br>
            <button id="generateArt">Generate Art</button>
            <button id="downloadImage" style="display: none;">Download Image</button>
            <button id="disconnectWallet" style="display: none;">Disconnect Wallet</button>
        </form>

        <canvas id="nftCanvas"></canvas>
    </div>

    <script>
        let web3;
        let account;
        let metadata;

        const contractAddress = "0xDA62572d99999B34791E6C34Cb8B125F368fa99A"; // Dirección de tu contrato
        const contractABI = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [],
		"name": "AlreadyMinted",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "ERC721IncorrectOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ERC721InsufficientApproval",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "approver",
				"type": "address"
			}
		],
		"name": "ERC721InvalidApprover",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			}
		],
		"name": "ERC721InvalidOperator",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "ERC721InvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "receiver",
				"type": "address"
			}
		],
		"name": "ERC721InvalidReceiver",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			}
		],
		"name": "ERC721InvalidSender",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ERC721NonexistentToken",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "MaxSupplyReached",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "OwnableInvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "OwnableUnauthorizedAccount",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "approved",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "ApprovalForAll",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "mint",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "minter",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "data",
				"type": "string"
			}
		],
		"name": "NFTMinted",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "safeTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "data",
				"type": "bytes"
			}
		],
		"name": "safeTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "setApprovalForAll",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"stateMutability": "payable",
		"type": "fallback"
	},
	{
		"stateMutability": "payable",
		"type": "receive"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "getApproved",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			}
		],
		"name": "isApprovedForAll",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ownerOf",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes4",
				"name": "interfaceId",
				"type": "bytes4"
			}
		],
		"name": "supportsInterface",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "symbol",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "tokenData",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "tokenURI",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
]; // ABI de tu contrato

        const colorPalettes = [
            ["#8E44AD", "#F39C12", "#E74C3C"], // Púrpura, naranja, rojo
            ["#3498DB", "#2ECC71", "#1ABC9C"], // Azul, verde, turquesa
            ["#F1C40F", "#E67E22", "#E74C3C"]  // Amarillo, naranja, rojo
        ];

        document.getElementById("connectWallet").addEventListener("click", async () => {
            if (window.ethereum) {
                try {
                    await ethereum.request({ method: 'eth_requestAccounts' });
                    web3 = new Web3(window.ethereum);
                    const accounts = await web3.eth.getAccounts();
                    account = accounts[0];
                    document.getElementById("walletAddress").innerText = `Address: ${account}`;
                    document.getElementById("nftForm").style.display = "block";
                    document.getElementById("disconnectWallet").style.display = "block";

                    fetchNFTData();
                } catch (error) {
                    console.error("Error connecting MetaMask:", error);
                }
            } else {
                alert("Please install MetaMask to use this feature.");
            }
        });

        document.getElementById("disconnectWallet").addEventListener("click", () => {
            account = null;
            document.getElementById("walletAddress").innerText = "Address: Not connected";
            document.getElementById("nftForm").style.display = "none";
            document.getElementById("disconnectWallet").style.display = "none";
        });

        async function fetchNFTData() {
            const contract = new web3.eth.Contract(contractABI, contractAddress);
            try {
                let tokenId;
                for (let i = 0; i < 5000; i++) {
                    try {
                        const owner = await contract.methods.ownerOf(i).call();
                        if (owner.toLowerCase() === account.toLowerCase()) {
                            tokenId = i;
                            break;
                        }
                    } catch (error) {
                        console.warn(`Token ID ${i} not found.`);
                    }
                }

                if (tokenId === undefined) {
                    alert("No NFT found for this wallet.");
                    return;
                }

                const tokenURI = await contract.methods.tokenURI(tokenId).call();
                metadata = JSON.parse(atob(tokenURI.split(",")[1]));

                document.getElementById("generateArt").disabled = false;
                console.log("NFT Metadata:", metadata);
            } catch (error) {
                console.error("Error fetching NFT data:", error);
                alert("Failed to retrieve NFT data.");
            }
        }

        function generateArtFromMetadata() {
            if (!metadata) {
                alert("Please connect your wallet and select a valid NFT.");
                return;
            }

            const angle = metadata.attributes.angle;
            const noise = metadata.attributes.noise;
            const color = BigInt(metadata.attributes.color);

            const sizeSelect = document.getElementById("size");
            const size = sizeSelect.value.split("x");
            const width = parseInt(size[0], 10);
            const height = parseInt(size[1], 10);

            generateArt(angle, noise, color, width, height, true);
            document.getElementById("downloadImage").style.display = "block";
        }

        function generateArt(angle, noise, colorSeed, width, height, scaleToFit = false) {
            const canvas = document.getElementById("nftCanvas");

            if (scaleToFit) {
                const aspectRatio = width / height;
                if (aspectRatio > 1) {
                    canvas.width = 800; // Limitar ancho para pantalla
                    canvas.height = 800 / aspectRatio;
                } else {
                    canvas.height = 600; // Limitar alto para pantalla
                    canvas.width = 600 * aspectRatio;
                }
            } else {
                canvas.width = width;
                canvas.height = height;
            }

            const ctx = canvas.getContext("2d");

            // Usar una paleta definida
            const paletteIndex = Number(colorSeed % BigInt(colorPalettes.length));
            const palette = colorPalettes[paletteIndex];
            const color1 = palette[0];
            const color2 = palette[1];

            console.log("Color 1:", color1);
            console.log("Color 2:", color2);

            const gradient = ctx.createLinearGradient(
                0, 0,
                Math.cos((angle * Math.PI) / 180) * canvas.width,
                Math.sin((angle * Math.PI) / 180) * canvas.height
            );

            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;

            for (let i = 0; i < pixels.length; i += 4) {
                const randomNoise = (Math.random() - 0.5) * noise;
                pixels[i] = Math.min(255, Math.max(0, pixels[i] + randomNoise));
                pixels[i + 1] = Math.min(255, Math.max(0, pixels[i + 1] + randomNoise));
                pixels[i + 2] = Math.min(255, Math.max(0, pixels[i + 2] + randomNoise));
            }
            ctx.putImageData(imageData, 0, 0);
        }

        document.getElementById("generateArt").addEventListener("click", (event) => {
            event.preventDefault();
            generateArtFromMetadata();
        });

        document.getElementById("downloadImage").addEventListener("click", () => {
            const canvas = document.getElementById("nftCanvas");
            const link = document.createElement("a");
            link.download = "nft_art.png";
            link.href = canvas.toDataURL();
            link.click();
        });
    </script>
</body>
</html>
