<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coderative-A NFT Viewer Test</title>
    <script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: "Courier New", Courier, monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .container {
            text-align: center;
            width: 80%;
            background: #001f00;
            border: 2px solid #0f0;
            padding: 20px;
            box-shadow: 0 0 10px #0f0;
        }

        button, select {
            margin: 10px 0;
            padding: 10px;
            font-size: 1rem;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            cursor: pointer;
        }

        canvas {
            margin-top: 20px;
            border: 2px solid #0f0;
        }

        button:hover, select:hover {
            background: #0f0;
            color: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Coderative-A NFT Viewer Test</h1>
        <button id="connectWallet">Connect Wallet</button>
        <p id="walletAddress">Address: Not connected</p>

        <label for="tokenId">Token ID:</label>
        <input type="number" id="tokenId" min="0" placeholder="Enter Token ID">

        <button id="generateArt">Generate Art</button>
        <canvas id="nftCanvas" width="512" height="512"></canvas>
    </div>

    <script>
        let web3;
        let contract;
        let account;

        const contractAddress = "0x09e702eFa89730cB399Ae7aB662668dA3af6B2BE"; // Replace with your contract address
        const contractABI = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [],
		"name": "AlreadyMinted",
		"type": "error"
	},
	{
		"inputs": [],
		"name": "MaxSupplyReached",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "approved",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "ApprovalForAll",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "mint",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "minter",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "string",
				"name": "data",
				"type": "string"
			}
		],
		"name": "NFTMinted",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"stateMutability": "payable",
		"type": "fallback"
	},
	{
		"stateMutability": "payable",
		"type": "receive"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ownerOf",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"name": "tokenData",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "tokenURI",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
];

        document.getElementById("connectWallet").addEventListener("click", async () => {
            if (window.ethereum) {
                web3 = new Web3(window.ethereum);
                try {
                    const accounts = await ethereum.request({ method: "eth_requestAccounts" });
                    account = accounts[0];
                    document.getElementById("walletAddress").innerText = `Address: ${account}`;
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                } catch (error) {
                    console.error("Error connecting to wallet:", error);
                }
            } else {
                alert("Please install MetaMask to use this feature.");
            }
        });

        document.getElementById("generateArt").addEventListener("click", async () => {
            const tokenId = document.getElementById("tokenId").value;
            if (!tokenId) {
                alert("Please enter a Token ID.");
                return;
            }

            try {
                const tokenURI = await contract.methods.tokenURI(tokenId).call();
                const decodedData = JSON.parse(atob(tokenURI.split(",")[1]));
                renderArt(decodedData.attributes);
            } catch (error) {
                console.error("Error fetching token data:", error);
                alert("Could not fetch token data. Ensure the token ID is correct.");
            }
        });

        function renderArt(attributes) {
            const canvas = document.getElementById("nftCanvas");
            const ctx = canvas.getContext("2d");

            const angle = attributes.angle;
            const noiseLevel = attributes.noise;
            const colorSeed = BigInt(attributes.color).toString(16).padStart(64, "0");

            const color1 = `#${colorSeed.slice(0, 6)}`;
            const color2 = `#${colorSeed.slice(6, 12)}`;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const gradient = ctx.createLinearGradient(0, 0, canvas.width * Math.cos(angle), canvas.height * Math.sin(angle));
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const randomNoise = (Math.random() - 0.5) * noiseLevel;
                data[i] = Math.min(255, Math.max(0, data[i] + randomNoise)); // Red
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + randomNoise)); // Green
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + randomNoise)); // Blue
            }

            ctx.putImageData(imageData, 0, 0);
        }
    </script>
</body>
</html>
